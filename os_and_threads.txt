Begin Data Section
0 20      # Initial PC - start at OS initialization code
1 999     # Initial SP - stack starts at 999 and grows down
2 0       # System call result
3 0       # Number of instructions executed
4 0       # Current running thread ID
5 0       # Number of active threads
6 100     # Thread table base (starts at 100)

# Thread table structure (20 bytes per thread):
# Base+0: Thread ID
# Base+1: Start time
# Base+2: Instructions executed
# Base+3: State (0=inactive, 1=ready, 2=running, 3=blocked)
# Base+4: PC
# Base+5: SP
# Rest: Reserved

# Numbers to sort for Thread 1 (moved to avoid conflicts)
1020 10   # N = 10 numbers to sort
1021 64   # Numbers to sort
1022 34
1023 25
1024 12
1025 22
1026 11
1027 90
1028 45
1029 33
1030 21

# Working variables for Thread 1
1031 0    # i (outer loop counter)
1032 0    # j (inner loop counter)
1033 0    # temp variable for swap
1034 0    # current element
1035 0    # next element
1036 0    # print counter

# Numbers for linear search in Thread 2
2020 10   # N = 10 numbers to search
2021 45   # Key to search for
2022 10   # Numbers to search in
2023 20
2024 30
2025 40
2026 45
2027 50
2028 60
2029 70
2030 80
2031 90

# Working variables for Thread 2
2032 0    # search index
2033 0    # current element
2034 -1   # result (-1 if not found)

# Custom thread data (Thread 3)
3020 5    # Counter for loop
End Data Section

Begin Instruction Section
# OS Initialization (starts at 20)
20 SET 100 6    # Set thread table base address
21 SET 0 5      # Initialize number of active threads

# Initialize Thread 1 (Bubble Sort)
22 SET 1 100    # Thread 1 ID
23 CPY 3 101    # Start time = current instruction count
24 SET 0 102    # Instructions executed = 0
25 SET 1 103    # State = ready
26 SET 1000 104 # PC = 1000 (thread 1 code)
27 SET 1990 105 # SP = 1990

# Initialize Thread 2 (Linear Search)
28 SET 2 120    # Thread 2 ID
29 CPY 3 121    # Start time
30 SET 0 122    # Instructions executed
31 SET 1 123    # State = ready
32 SET 2000 124 # PC = 2000
33 SET 2990 125 # SP = 2990

# Initialize Thread 3 (Custom)
34 SET 3 140    # Thread 3 ID
35 CPY 3 141    # Start time
36 SET 0 142    # Instructions executed
37 SET 1 143    # State = ready
38 SET 3000 144 # PC = 3000
39 SET 3990 145 # SP = 3990

# Start first thread
40 SET 1 4      # Set current thread to 1
41 SET 3 5      # Set number of active threads
42 SET 2 103    # Set thread 1 state to running
43 SET 1000 0   # Set PC to first thread
44 USER 0       # Switch to user mode and jump to thread 1

# OS Scheduler (called after YIELD at address 50)
50 SET 1 4      # Reset to thread 1 for now (simple scheduling)
51 SET 1000 0   # Set PC to thread 1
52 USER 0       # Switch to user mode

# Thread 1 - Bubble Sort
1000 SET 0 1031     # i = 0 (outer loop)

# Outer loop condition
1001 CPY 1020 1040  # Load N
1002 SUBI 1040 1    # N-1 for outer loop limit
1003 CPY 1031 1041  # Load i
1004 SUBI 1041 1040 # Compare i with N-1
1005 JIF 1041 1060  # If i >= N-1, done with outer loop

# Inner loop initialization
1006 SET 0 1032     # j = 0

# Inner loop condition
1007 CPY 1020 1040  # Load N
1008 SUBI 1040 1    # N-1 for inner loop limit
1009 CPY 1031 1041  # Subtract i from N-1
1010 SUBI 1040 1041 # N-1-i is our limit
1011 CPY 1032 1041  # Load j
1012 SUBI 1041 1040 # Compare j with N-1-i
1013 JIF 1041 1050  # If j >= N-1-i, done with inner loop

# Load and compare adjacent elements
1014 CPY 1032 1042  # Load j
1015 ADD 1042 1021  # Calculate address of arr[j]
1016 CPY 1042 1034  # Get arr[j]

1017 CPY 1032 1043  # Load j
1018 ADD 1043 1     # j+1
1019 ADD 1043 1021  # Calculate address of arr[j+1]
1020 CPY 1043 1035  # Get arr[j+1]

# Compare elements
1021 CPY 1034 1044  # Copy arr[j]
1022 SUBI 1044 1035 # Compare arr[j] - arr[j+1]
1023 JIF 1044 1030  # If arr[j] <= arr[j+1], no swap needed

# Perform swap
1024 CPY 1034 1033  # temp = arr[j]
1025 CPY 1032 1045  # Load j
1026 ADD 1045 1021  # Calculate address of arr[j]
1027 CPY 1035 1045  # arr[j] = arr[j+1]
1028 CPY 1032 1046  # Load j
1029 ADD 1046 1     # j+1
1030 ADD 1046 1021  # Calculate address of arr[j+1]
1031 CPY 1033 1046  # arr[j+1] = temp

# Continue inner loop
1032 ADD 1032 1     # j++
1033 SYSCALL YIELD  # Yield to other threads
1034 SET 1007 0     # Jump back to inner loop condition

# End of inner loop
1050 ADD 1031 1     # i++
1051 SYSCALL YIELD  # Yield to other threads
1052 SET 1001 0     # Jump back to outer loop

# Print sorted array
1060 SET 0 1036     # Initialize print counter
1061 CPY 1020 1050  # Load N
1062 CPY 1036 1051  # Load print counter
1063 SUBI 1051 1050 # Compare counter with N
1064 JIF 1051 1070  # If counter >= N, done printing

1065 CPY 1036 1052  # Load counter
1066 ADD 1052 1021  # Calculate address of element
1067 SYSCALL PRN 1052 # Print the element
1068 ADD 1036 1     # Increment counter
1069 SET 1061 0     # Jump back to print loop

1070 SYSCALL HLT    # End thread

# Thread 2 - Linear Search
2000 SET 0 2032     # Initialize search index
2001 SET -1 2034    # Initialize result to -1 (not found)

# Search loop
2002 CPY 2020 2040  # Load N
2003 CPY 2032 2041  # Load current index
2004 SUBI 2041 2040 # Compare index with N
2005 JIF 2041 2015  # If index >= N, search done

# Get current element and compare with key
2006 CPY 2032 2042  # Load current index
2007 ADD 2042 2022  # Calculate address (base + index)
2008 CPY 2042 2033  # Get current element
2009 CPY 2021 2044  # Get search key
2010 CPY 2033 2045  # Copy current element
2011 SUBI 2045 2044 # Compare with key (element - key)
2012 JIF 2045 2016  # If equal (difference is 0), found

# Continue search
2013 ADD 2032 1     # Increment index
2014 SET 2002 0     # Loop back to start

# Not found
2015 SET -1 2034    # Set result to -1
2016 CPY 2034 2046  # Copy result for printing
2017 SYSCALL PRN 2046  # Print result
2018 SYSCALL HLT    # End thread

# Thread 3 - Custom (Count down and print)
3000 CPY 3020 3021  # Load counter value
3001 SYSCALL PRN 3021 # Print current value
3002 ADD 3020 -1    # Decrement counter in memory
3003 CPY 3020 3022  # Load counter to check
3004 JIF 3022 3007  # If counter <= 0, exit
3005 SYSCALL YIELD  # Yield to other threads
3006 SET 3000 0     # Jump back to start
3007 SYSCALL HLT    # End thread
End Instruction Section